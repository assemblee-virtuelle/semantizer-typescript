import Context from "../core/Context.js";
import { DocumentBase, ReadonlyDocument, Document, WithReadOperations } from "../core/Document.js";
import Resource from "../core/Resource.js";
import Thing, { ReadonlyThing, ThingBase } from "../core/Thing.js";
import ThingFactory from '../core/ThingFactory.js';
declare class DocumentBaseDefaultImpl<DocumentType extends (DocumentBase<ContainedThing, SelfDescribingThing> & WithReadOperations<DocumentType, ContainedThing, SelfDescribingThing>), ContainedThing extends ThingBase, SelfDescribingThing extends ThingBase> {
    protected _uri: string;
    protected _selfDescribingThing?: SelfDescribingThing;
    protected _things: ContainedThing[];
    protected _context?: Context;
    constructor(documentOrUri?: DocumentBase<ContainedThing, SelfDescribingThing> | string, context?: Context);
    at(index: number): ContainedThing | undefined;
    contains(other: DocumentType): boolean;
    difference(other: DocumentType): DocumentType;
    every(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => boolean, thisArg?: any): boolean;
    find(predicate: (value: ContainedThing, index: number, obj: ContainedThing[]) => value is ContainedThing, thisArg?: any): ContainedThing | undefined;
    findIndex(predicate: (value: ContainedThing, index: number, obj: ContainedThing[]) => unknown, thisArg?: any): number;
    get(uri: string | Resource): ContainedThing | undefined;
    has(uriOrResource: string | Resource): boolean;
    hasThingThatSelfDescribes(): boolean;
    hasContainedThingThatSelfDescribes(): boolean;
    includes(searchElement: ContainedThing, fromIndex?: number | undefined): boolean;
    protected getUriFromStringOrResource(stringOrResource: string | Resource): string;
    indexOf(searchElement: ContainedThing, fromIndex?: number | undefined): number;
    keys(): IterableIterator<number>;
    reduce(callbackfn: (previousValue: ContainedThing, currentValue: ContainedThing, currentIndex: number, array: ContainedThing[]) => ContainedThing): ContainedThing;
    slice(start?: number, end?: number): DocumentType;
    some(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): boolean;
    toCanonical(): string;
    toGenericDocument(): DocumentBase<Thing, Thing>;
    toStream(): string;
    forEach(callbackfn: (value: ContainedThing, index: number, array: ContainedThing[]) => void, thisArg?: any): void;
    map(callbackfn: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): unknown[];
    [Symbol.iterator](): Iterator<ContainedThing>;
    setContext(context: Context): void;
    getContext(): Context | undefined;
    expand(uri: string): string;
    shorten(uri: string): string;
    equals(other: DocumentBase<ContainedThing, SelfDescribingThing>): boolean;
    protected isUrl(input: string): boolean;
    getUri(): string;
    isEmpty(): boolean;
    protected _getContainedThings(): ContainedThing[];
    getThingThatSelfDescribes(): SelfDescribingThing | undefined;
    count(callbackfn?: ((thing: ContainedThing, document?: DocumentType) => boolean) | undefined): number;
    hasStatementsAbout(subject: string | Resource, property?: string, ...hasValues: string[]): boolean;
    filter(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => boolean): ContainedThing[];
}
export declare class ReadonlyDocumentDefaultImpl<ContainedThing extends ReadonlyThing = ReadonlyThing, SelfDescribingThing extends ReadonlyThing = ReadonlyThing> extends DocumentBaseDefaultImpl<ReadonlyDocument<ContainedThing, SelfDescribingThing>, ContainedThing, SelfDescribingThing> implements ReadonlyDocument<ContainedThing, SelfDescribingThing> {
    constructor(documentOrUri?: DocumentBase<ContainedThing, SelfDescribingThing> | string, context?: Context);
    toCopy(): ReadonlyDocument<ContainedThing, SelfDescribingThing>;
    toCopyWritable<ContainedWritableThing extends Thing = Thing, SelfDescribingWritableThing extends Thing = Thing>(): Document<ContainedWritableThing, SelfDescribingWritableThing>;
}
export declare class DocumentDefaultImpl<ContainedThing extends Thing = Thing, SelfDescribingThing extends Thing = Thing> extends DocumentBaseDefaultImpl<Document<ContainedThing, SelfDescribingThing>, ContainedThing, SelfDescribingThing> implements Document<ContainedThing, SelfDescribingThing> {
    protected _thingFactory: ThingFactory<ContainedThing, SelfDescribingThing>;
    constructor(documentOrUri?: DocumentBase<ContainedThing, SelfDescribingThing> | string, context?: Context, thingFactory?: ThingFactory<ContainedThing, SelfDescribingThing>);
    getContainedThingFactory(): ThingFactory<ContainedThing, SelfDescribingThing>;
    add(thing: ContainedThing): Document<ContainedThing, SelfDescribingThing>;
    addAll(documentOrThings: ReadonlyDocument<ContainedThing, SelfDescribingThing> | ContainedThing[]): Document<ContainedThing, SelfDescribingThing>;
    delete(thingOrUri: string | ContainedThing): Document<ContainedThing, SelfDescribingThing>;
    deleteContext(): void;
    deleteMatches(uri?: string | Resource | undefined, property?: string | undefined, value?: string | undefined): Document<ContainedThing, SelfDescribingThing>;
    pop(): ContainedThing | undefined;
    reverse(): void;
    shift(): ContainedThing | undefined;
    sort(compareFn?: ((a: ContainedThing, b: ContainedThing) => number) | undefined): Document<ContainedThing, SelfDescribingThing>;
    splice(start: number, deleteCount?: number | undefined, ...items: ContainedThing[]): Document<ContainedThing, SelfDescribingThing>;
    union(other: DocumentBase<ContainedThing, SelfDescribingThing>): Document<ContainedThing, SelfDescribingThing>;
    protected setContainedThings(things: ContainedThing[]): void;
    protected addAndReturnContainedThing(thing: ContainedThing): ContainedThing;
    protected generateUriWithFragment(): string;
    protected getOrCreateNameWithHash(nameWithOrWithoutHash: string): string;
    protected createUriWithFragment(name: string): string;
    protected checkUriCanBeAddedToTheDocument<ContainedThing, SelfDescribingThing>(uri: string): boolean;
    protected getSafeUriFromUri(uri: string): string;
    protected getSafeUriFromName(name: string): string;
    protected getSafeUriFromNameHintOrUri(nameHintOrUri: string): string;
    createThingToSelfDescribe(): SelfDescribingThing;
    createThingWithUri(nameHintOrUri?: string): ContainedThing;
    createThingWithoutUri(nameHint?: string): ContainedThing;
    generateContainedThingName(): string;
    protected validateOrCreateContainedThingUri(nameHintOrUri?: string): string;
    protected validateNameHintForContainedThingWithoutUri(nameHint: string): void;
    protected validateAndCreateContainedThingWithoutUri(nameHint?: string): ContainedThing;
    setUri(uri: string): void;
    protected setThingThatSelfDescribes(thing: SelfDescribingThing): SelfDescribingThing | undefined;
    toCopy(): Document<ContainedThing, SelfDescribingThing>;
    toCopyReadonly(): ReadonlyDocument<ContainedThing, SelfDescribingThing>;
}
export default DocumentDefaultImpl;
//# sourceMappingURL=DocumentDefaultImpl.d.ts.map