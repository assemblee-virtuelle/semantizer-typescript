import { Context } from "../core/Context.js";
import { Document, DocumentBase, DocumentReadonly } from "../core/Document.js";
import Factory, { FactoryForCopying } from "../core/Factory.js";
import Resource from "../core/Resource.js";
import { Statement, StatementReadonly } from "../core/Statement.js";
import { Thing, ThingReadonly } from "../core/Thing.js";
export declare class DocumentImpl<ContainedThing extends Thing<any, any> | ThingReadonly<any, any>, SelfDescribingThing extends Thing<any, any> | ThingReadonly<any, any>, ContainedThingReadonly extends ThingReadonly<any, any>, SelfDescribingThingReadonly extends ThingReadonly<any, any>> implements Document<ContainedThing, SelfDescribingThing, ContainedThingReadonly, SelfDescribingThingReadonly> {
    protected _uri: string;
    protected _selfDescribingThing?: SelfDescribingThing;
    protected _things: ContainedThing[];
    protected _context?: Context;
    protected _factory: Factory<this>;
    constructor(factory: Factory<any>);
    getFactoryForCopying(): FactoryForCopying<DocumentBase<ContainedThing, SelfDescribingThing>, DocumentReadonly<ContainedThingReadonly, SelfDescribingThingReadonly, ContainedThing, SelfDescribingThing>>;
    getFactory(): Factory<Document<ContainedThing, SelfDescribingThing, ContainedThingReadonly, SelfDescribingThingReadonly>>;
    toCopy(): this;
    toCopyReadonly(): DocumentReadonly<ContainedThingReadonly, SelfDescribingThingReadonly, ContainedThing, SelfDescribingThing>;
    createThingToSelfDescribe(): SelfDescribingThing;
    createThingWithoutUri(nameHint?: string | undefined): ContainedThing;
    add(thing: ContainedThing): this;
    addAll(documentOrThings: DocumentBase<any, any> | ContainedThing[]): this;
    delete(thingOrUri: string | ContainedThing): this;
    deleteContext(): void;
    deleteMatches(uri?: string | Resource | undefined, property?: string | undefined, value?: string | undefined): this;
    pop(): ContainedThing | undefined;
    reverse(): void;
    setContext(context: Context): void;
    shift(): ContainedThing | undefined;
    sort(compareFn?: ((a: ContainedThing, b: ContainedThing) => number) | undefined): this;
    splice(start: number, deleteCount?: number | undefined, ...items: ContainedThing[]): this;
    union(other: DocumentBase<any, any>): this;
    protected addAndReturnContainedThing(thing: ContainedThing): ContainedThing;
    generateContainedThingName(): string;
    protected generateUriWithFragment(): string;
    protected getOrCreateNameWithHash(nameWithOrWithoutHash: string): string;
    protected createUriWithFragment(name: string): string;
    protected checkUriCanBeAddedToTheDocument<ContainedThing, SelfDescribingThing>(uri: string): boolean;
    protected getSafeUriFromUri(uri: string): string;
    protected getSafeUriFromName(name: string): string;
    protected getSafeUriFromNameHintOrUri(nameHintOrUri: string): string;
    protected validateOrCreateContainedThingUri(nameHintOrUri?: string): string;
    createThingWithUri(nameHintOrUri?: string): ContainedThing;
    protected isUrl(input: string): boolean;
    protected hasStatementsAbout(subject: string | Resource, property?: string, ...hasValues: string[]): boolean;
    protected _getContainedThings(): ContainedThing[];
    count(callbackfn?: (thing: ContainedThing, document?: this) => boolean): number;
    get(uri: string | Resource): ContainedThing | undefined;
    getContext(): Context | undefined;
    getThingThatSelfDescribes(): SelfDescribingThing | undefined;
    has(uriOrResource: string | Resource): boolean;
    hasThingThatSelfDescribes(): boolean;
    getUri(): string;
    isEmpty(): boolean;
    toCanonical(): string;
    toStream(): string;
    [Symbol.iterator](): Iterator<ContainedThing>;
    at(index: number): ContainedThing | undefined;
    contains(other: this): boolean;
    difference(other: DocumentBase<any, any>): this;
    every(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => boolean, thisArg?: any): boolean;
    find(predicate: (value: ContainedThing, index: number, obj: ContainedThing[]) => boolean, thisArg?: any): ContainedThing | undefined;
    findIndex(predicate: (value: ContainedThing, index: number, obj: ContainedThing[]) => unknown, thisArg?: any): number;
    includes(searchElement: ContainedThing, fromIndex?: number | undefined): boolean;
    indexOf(searchElement: ContainedThing, fromIndex?: number | undefined): number;
    keys(): IterableIterator<number>;
    reduce(callbackfn: (previousValue: ContainedThing, currentValue: ContainedThing, currentIndex: number, array: ContainedThing[]) => ContainedThing): ContainedThing;
    slice(start?: number, end?: number): this;
    some(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): boolean;
    forEach(callbackfn: (value: ContainedThing, index: number, array: ContainedThing[]) => void, thisArg?: any): void;
    map(callbackfn: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): unknown[];
    equals(other: DocumentBase<any, any>): boolean;
    filter(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => boolean): ContainedThing[];
}
export declare class DocumentImplReadonly<ContainedThing extends ThingReadonly<StatementReadonly<any>, any>, SelfDescribingThing extends ThingReadonly<StatementReadonly<any>, any>, ContainedThingWritable extends Thing<Statement<any>, any> | ThingReadonly<any, any>, SelfDescribingThingWritable extends Thing<Statement<any>, any> | ThingReadonly<any, any>> implements DocumentReadonly<ContainedThing, SelfDescribingThing, ContainedThingWritable, SelfDescribingThingWritable> {
    constructor(document: Document<any, any, any, any>);
    get(uri: string | Resource): ContainedThing | undefined;
    getContext(): Context | undefined;
    getThingThatSelfDescribes(): SelfDescribingThing | undefined;
    has(thing: string | Resource): boolean;
    hasThingThatSelfDescribes(): boolean;
    isEmpty(): boolean;
    toCanonical(): string;
    toStream(): string;
    toCopy(): ThisType<this>;
    [Symbol.iterator](): Iterator<ContainedThing, any, undefined>;
    getUri(): string;
    getFactoryForCopying(): FactoryForCopying<DocumentBase<ContainedThing, SelfDescribingThing>, Document<ContainedThingWritable, SelfDescribingThingWritable, ContainedThing, SelfDescribingThing>>;
    at(index: number): ContainedThing | undefined;
    contains(other: ThisType<this>): boolean;
    count(callbackfn?: ((thing: ContainedThing, document?: ThisType<this> | undefined) => boolean) | undefined): number;
    difference(other: ThisType<this>): ThisType<this>;
    equals(other: ThisType<this>): boolean;
    every(predicate: (value: ContainedThing, index?: number | undefined, array?: ContainedThing[] | undefined) => boolean, thisArg?: any): boolean;
    filter(predicate: (value: ContainedThing, index?: number | undefined, array?: ContainedThing[] | undefined) => boolean): ContainedThing[];
    find(predicate: (value: ContainedThing, index?: number | undefined, obj?: ContainedThing[] | undefined) => boolean, thisArg?: any): ContainedThing | undefined;
    findIndex(predicate: (value: ContainedThing, index?: number | undefined, obj?: ContainedThing[] | undefined) => unknown, thisArg?: any): number;
    forEach(callbackfn: (value: ContainedThing, index?: number | undefined, array?: ContainedThing[] | undefined) => void, thisArg?: any): void;
    includes(searchElement: ContainedThing, fromIndex?: number | undefined): boolean;
    indexOf(searchElement: ContainedThing, fromIndex?: number | undefined): number;
    keys(): IterableIterator<number>;
    map(callbackfn: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): unknown[];
    reduce(callbackfn: (previousValue: ContainedThing, currentValue: ContainedThing, currentIndex: number, array: ContainedThing[]) => ContainedThing): ContainedThing;
    slice(start?: number | undefined, end?: number | undefined): ThisType<this>;
    some(predicate: (value: ContainedThing, index: number, array: ContainedThing[]) => unknown, thisArg?: any): boolean;
    toCopyWritable<DocumentType extends Document<any, any, any, any>>(): DocumentType;
}
export default DocumentImpl;
//# sourceMappingURL=DocumentImpl.d.ts.map