import Document, { ReadonlyDocument } from "../core/Document";
import TypeIndexRegistration from "./TypeIndexRegistration";
type Constructor<T = {}> = new (...args: any[]) => T;
export declare function ReadonlyTypeIndexMixin<TBase extends Constructor<ReadonlyDocument<any, any>>>(Base: TBase): {
    new (...args: any[]): {
        forEachOfClass(forClass: string, callbackfn: (value: TypeIndexRegistration, index: number, array: TypeIndexRegistration[]) => void, thisArg?: any): void;
        get(uri: string | import("../core/Resource").Resource): any;
        getContext(): import("../index").Context | undefined;
        getThingThatSelfDescribes(): any;
        has(thing: string | import("../core/Resource").Resource): boolean;
        hasThingThatSelfDescribes(): boolean;
        isEmpty(): boolean;
        toCanonical(): string;
        toStream(): string;
        [Symbol.iterator](): Iterator<any, any, undefined>;
        getUri(): string;
        at(index: number): any;
        contains(other: ReadonlyDocument<any, any>): boolean;
        count(callbackfn?: ((thing: any, document?: ReadonlyDocument<any, any> | undefined) => boolean) | undefined): number;
        difference(other: ReadonlyDocument<any, any>): ReadonlyDocument<any, any>;
        equals(other: ReadonlyDocument<any, any>): boolean;
        every(predicate: (value: any, index?: number | undefined, array?: any[] | undefined) => boolean, thisArg?: any): boolean;
        filter(predicate: (value: any, index?: number | undefined, array?: any[] | undefined) => boolean): any[];
        find(predicate: (value: any, index?: number | undefined, obj?: any[] | undefined) => value is any, thisArg?: any): any;
        findIndex(predicate: (value: any, index?: number | undefined, obj?: any[] | undefined) => unknown, thisArg?: any): number;
        forEach(callbackfn: (value: any, index?: number | undefined, array?: any[] | undefined) => void, thisArg?: any): void;
        includes(searchElement: any, fromIndex?: number | undefined): boolean;
        indexOf(searchElement: any, fromIndex?: number | undefined): number;
        keys(): IterableIterator<number>;
        map(callbackfn: (value: any, index: number, array: any[]) => unknown, thisArg?: any): unknown[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        slice(start?: number | undefined, end?: number | undefined): ReadonlyDocument<any, any>;
        some(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        toGenericReadonlyDocument(): ReadonlyDocument<any, any>;
    };
} & TBase;
export declare function TypeIndexMixin<TBase extends Constructor<Document<any, any>>>(Base: TBase): {
    new (...args: any[]): {
        createRegistration(forClass?: string, nameHintOrUri?: string | undefined): TypeIndexRegistration;
        forEachOfClass(forClass: string, callbackfn: (value: TypeIndexRegistration, index: number, array: TypeIndexRegistration[]) => void, thisArg?: any): void;
        get(uri: string | import("../core/Resource").Resource): any;
        getContext(): import("../index").Context | undefined;
        getThingThatSelfDescribes(): any;
        has(thing: string | import("../core/Resource").Resource): boolean;
        hasThingThatSelfDescribes(): boolean;
        isEmpty(): boolean;
        toCanonical(): string;
        toStream(): string;
        [Symbol.iterator](): Iterator<any, any, undefined>;
        getUri(): string;
        at(index: number): any;
        contains(other: ReadonlyDocument<any, any>): boolean;
        count(callbackfn?: ((thing: any, document?: ReadonlyDocument<any, any> | undefined) => boolean) | undefined): number;
        difference(other: ReadonlyDocument<any, any>): ReadonlyDocument<any, any>;
        equals(other: ReadonlyDocument<any, any>): boolean;
        every(predicate: (value: any, index?: number | undefined, array?: any[] | undefined) => boolean, thisArg?: any): boolean;
        filter(predicate: (value: any, index?: number | undefined, array?: any[] | undefined) => boolean): any[];
        find(predicate: (value: any, index?: number | undefined, obj?: any[] | undefined) => value is any, thisArg?: any): any;
        findIndex(predicate: (value: any, index?: number | undefined, obj?: any[] | undefined) => unknown, thisArg?: any): number;
        forEach(callbackfn: (value: any, index?: number | undefined, array?: any[] | undefined) => void, thisArg?: any): void;
        includes(searchElement: any, fromIndex?: number | undefined): boolean;
        indexOf(searchElement: any, fromIndex?: number | undefined): number;
        keys(): IterableIterator<number>;
        map(callbackfn: (value: any, index: number, array: any[]) => unknown, thisArg?: any): unknown[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        slice(start?: number | undefined, end?: number | undefined): ReadonlyDocument<any, any>;
        some(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        toGenericReadonlyDocument(): ReadonlyDocument<any, any>;
        add(thing: any): Document<any, any>;
        addAll(documentOrThings: any[] | ReadonlyDocument<any, any>): Document<any, any>;
        createThingToSelfDescribe(): any;
        createThingWithUri(nameHintOrUri?: string | undefined): any;
        createThingWithoutUri(nameHint?: string | undefined): any;
        delete(thingOrUri: any): Document<any, any>;
        deleteContext(): void;
        deleteMatches(uri?: string | import("../core/Resource").Resource | undefined, property?: string | undefined, value?: string | undefined): Document<any, any>;
        pop(): any;
        reverse(): void;
        setContext(context: import("../index").Context): void;
        shift(): any;
        sort(compareFn?: ((a: any, b: any) => number) | undefined): Document<any, any>;
        splice(start: number, deleteCount?: number | undefined, ...items: any[]): Document<any, any>;
        toGenericDocument(): Document<any, any>;
        union(other: ReadonlyDocument<any, any>): Document<any, any>;
    };
} & TBase;
export default TypeIndexMixin;
//# sourceMappingURL=TypeIndexMixin.d.ts.map