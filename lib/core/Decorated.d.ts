import { Context } from "./Context";
import { ContainedThingOf, Document, DocumentBase, DocumentDecorated, SelfDescribingThingOf } from "./Document";
import Factory, { FactoryForCopying } from "./Factory";
import Resource from "./Resource";
import { StatementBase, StatementReadonly } from "./Statement";
import { Thing, ThingBase, ThingReadonly } from "./Thing";
export declare class DocumentDecoratedImpl<DocumentType extends Document<any, any>, DocumentTypeReadonly extends DocumentBase<ThingReadonly<StatementReadonly<any>, any>, ThingReadonly<StatementReadonly<any>, any>>> implements DocumentDecorated<DocumentType, DocumentTypeReadonly> {
    protected _wrapped: Document<DocumentType, DocumentTypeReadonly>;
    constructor(wrapped: Document<DocumentType, DocumentTypeReadonly>);
    getFactoryForCopying(): FactoryForCopying<Document<DocumentType, DocumentTypeReadonly>>;
    getFactory(): Factory<Document<DocumentType, DocumentTypeReadonly>>;
    toCopy(): this;
    toCopyReadonly(): DocumentTypeReadonly;
    toCopyWritable(): DocumentType;
    createThingToSelfDescribe(): SelfDescribingThingOf<DocumentType>;
    createThingWithoutUri(nameHint?: string | undefined): ContainedThingOf<DocumentType>;
    add(thing: ContainedThingOf<DocumentType>): this;
    addAll(documentOrThings: DocumentType | ContainedThingOf<DocumentType>[]): this;
    delete(thingOrUri: string | ContainedThingOf<DocumentType>): this;
    deleteContext(): void;
    deleteMatches(uri?: string | Resource | undefined, property?: string | undefined, value?: string | undefined): this;
    pop(): ContainedThingOf<DocumentType> | undefined;
    reverse(): void;
    setContext(context: Context): void;
    shift(): ContainedThingOf<DocumentType> | undefined;
    sort(compareFn?: ((a: ContainedThingOf<DocumentType>, b: ContainedThingOf<DocumentType>) => number) | undefined): this;
    splice(start: number, deleteCount?: number | undefined, ...items: ContainedThingOf<DocumentType>[]): this;
    union(other: DocumentType): this;
    createThingWithUri(nameHintOrUri?: string): ContainedThingOf<DocumentType>;
    getWrappedDocument(): Document<DocumentType, DocumentTypeReadonly>;
    get(uri: string | Resource): ThisType<ContainedThingOf<DocumentType>> | undefined;
    getContext(): Context | undefined;
    getThingThatSelfDescribes(): SelfDescribingThingOf<DocumentType> | undefined;
    has(thing: string | Resource): boolean;
    hasThingThatSelfDescribes(): boolean;
    isEmpty(): boolean;
    toCanonical(): string;
    toStream(): string;
    [Symbol.iterator](): Iterator<ContainedThingOf<DocumentType>>;
    getUri(): string;
    at(index: number): ThisType<ContainedThingOf<DocumentType>> | undefined;
    contains(other: this): boolean;
    count(callbackfn?: (thing: ThisType<ContainedThingOf<DocumentType>>, document?: ThisType<this>) => boolean): number;
    difference(other: this): this;
    equals(other: this): boolean;
    every(predicate: (value: ThisType<ContainedThingOf<DocumentType>>, index?: number | undefined, array?: ThisType<ContainedThingOf<DocumentType>>[] | undefined) => boolean, thisArg?: any): boolean;
    filter(predicate: (value: ThisType<ContainedThingOf<DocumentType>>, index?: number | undefined, array?: ThisType<ContainedThingOf<DocumentType>>[] | undefined) => boolean): ThisType<ContainedThingOf<DocumentType>>[];
    find(predicate: (value: ThisType<ContainedThingOf<DocumentType>>, index?: number | undefined, obj?: ThisType<ContainedThingOf<DocumentType>>[] | undefined) => boolean, thisArg?: any): ThisType<ContainedThingOf<DocumentType>> | undefined;
    findIndex(predicate: (value: ThisType<ContainedThingOf<DocumentType>>, index?: number | undefined, obj?: ThisType<ContainedThingOf<DocumentType>>[] | undefined) => unknown, thisArg?: any): number;
    forEach(callbackfn: (value: ContainedThingOf<DocumentType>, index?: number | undefined, array?: ContainedThingOf<DocumentType>[] | undefined) => void, thisArg?: any): void;
    includes(searchElement: ThisType<ContainedThingOf<DocumentType>>, fromIndex?: number | undefined): boolean;
    indexOf(searchElement: ThisType<ContainedThingOf<DocumentType>>, fromIndex?: number | undefined): number;
    keys(): IterableIterator<number>;
    map(callbackfn: (value: ThisType<ContainedThingOf<DocumentType>>, index: number, array: ThisType<ContainedThingOf<DocumentType>>[]) => unknown, thisArg?: any): unknown[];
    reduce(callbackfn: (previousValue: ThisType<ContainedThingOf<DocumentType>>, currentValue: ThisType<ContainedThingOf<DocumentType>>, currentIndex: number, array: ThisType<ContainedThingOf<DocumentType>>[]) => ThisType<ContainedThingOf<DocumentType>>): ThisType<ContainedThingOf<DocumentType>>;
    slice(start?: number | undefined, end?: number | undefined): this;
    some(predicate: (value: ThisType<ContainedThingOf<DocumentType>>, index: number, array: ThisType<ContainedThingOf<DocumentType>>[]) => unknown, thisArg?: any): boolean;
}
export declare class ThingDecorated<ContainedStatement extends StatementBase, //<any>, 
DocumentType extends Document<any, any>> implements Thing<ContainedStatement, DocumentType> {
    private _wrapped;
    constructor(wrapped: Thing<ContainedStatement, DocumentType>);
    getWrappedThing(): Thing<ContainedStatement, DocumentType>;
    getContext(): Context | undefined;
    hasUri(): boolean;
    count(): number;
    isEmpty(): boolean;
    equals(other: ThingBase<any>): boolean;
    get(property: string): ContainedStatement | undefined;
    getAll(property: string): ContainedStatement[];
    toCopy(): ThisType<this>;
    [Symbol.iterator](): Iterator<ContainedStatement>;
    getUri(): string;
    getDocument(): DocumentType;
    forEach(callbackfn: (value: ContainedStatement, index: number, array: ContainedStatement[]) => void, thisArg?: any): void;
    map(callbackfn: (value: ContainedStatement, index: number, array: ContainedStatement[]) => unknown, thisArg?: any): unknown[];
    filter(predicate: (value: ContainedStatement, index: number, array: ContainedStatement[]) => boolean): ContainedStatement[];
    add(statement: ContainedStatement): ThisType<this>;
    remove(about: string, value: string | Resource, datatype?: string | undefined, language?: string | undefined): ThisType<this>;
    removeAll(about: string): ThisType<this>;
    set(about: string, value: string, oldValue?: string | undefined, datatype?: string | undefined, language?: string | undefined): ThisType<this>;
    createStatement(about: string, value: string | Resource, datatype?: string | undefined, language?: string | undefined): this;
    toCopyReadonly(): ContainedThingOf<DocumentType>;
    toCopyWritable(): ContainedThingOf<DocumentType>;
}
export default DocumentDecoratedImpl;
//# sourceMappingURL=Decorated.d.ts.map